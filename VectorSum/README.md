# Лабораторная работа 2 :octocat:
## Сумма элементов вектора
**Задача**: реализовать алгоритм сложения элементов вектора <br/>
**Язык**: Python<br/>
**Входные данные**: Вектор размером 1 000 .. 1 000 000 значений<br/>
**Выходные данные**: сумма элементов вектора + время вычисления<br/>
## **Техническое обеспечение**
+ Процессор: Intel(R) Xeon(R) CPU @ 2.30GHz
+ Графический процессор: Tesla K80
## **Описание**
Язык Python 3.7 с использованием библиотек Numba, Numpy.
В программе реализованны три функции:
+ ```cpu_vectorsum_numpy``` - функция вычисления суммы всех элементов вектора ```np.sum()```, реализованная в библиотеке ```numpy```.
+ ```cpu_vectorsum``` - функция вычисления суммы всех элементов вектора на CPU.
+ ```gpu_vectorsum``` - функция с применением декоратора ```@cuda.jit```, который выполняет суммирование элементов вектора на GPU с помощью технологии CUDA. Для ускорения была создана область общей памяти (переменная ```b```) для каждого отдельного блока. В данной функции сначала производится суммирование элементов в каждом отдельном блоке, а затем полученные суммы уже суммируются в глобальную суммы с помощью функции ```cuda.atomic.add```.
## **Результаты**
В таблице приведены результаты вычисления суммы элементов вектора на CPU и GPU соответственно:
Кол-во эл-тов вектора | Расчет на CPU (np.sum), сек | Расчет на CPU, сек | Расчет на GPU, сек | Ускорение (CPU/GPU)
------------ | ------------- | ------------- | ------------- | ------------- 
1000 | 0.000153 | 0.000597 | 0.991152 | 0.000602
10000 | 0.000146 | 0.005409 | 0.003825 | 1.41
100000 | 0.000523 | 0.052949 | 0.003392 | 15.6
500000 | 0.005715 | 0.270727 | 0.002571 | 105.3
1000000 | 0.005411 | 0.532872 | 0.003406 | 79.4

### График сравнения времени вычисления в зависимости от количества элементов вектора
![vectorsum](https://drive.google.com/uc?export=view&id=1STYcgnap6JbxOmB3CrUuqizKhjqxvCvw)
<br/>
 По оси X - количество элементов вектора;<br/>
 По оси Y - время выполнения расчета элементов вектора.<br/>
 
 ## **Заключение**
 По полученным результатам можно сделать вывод, что реализованная функция сложения элементов вектора на GPU с помощью технологии CUDA дает значительное преимущество, когда количество элементов вектора становится всё больше. Однако по сравнению с аналогичной функцией из библиотеки ```numpy```, преимущество вычисления на GPU не такое явное (~ в 1.5-2 раза) по сравнению с вычислением суммы на CPU без использования сторонних библиотек. Причина этого может заключаться в том, что большая часть времени в расчете суммы на GPU уходит на копирование вектора с CPU на GPU и обратно.
